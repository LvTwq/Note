[toc]

# 一、NoSql简介

## 1、概述

Not Only SQL（不仅仅是SQL），泛指**非关系型数据库**，不依赖**业务逻辑**方式存储，而用简单的**key-value**模式存储，大大增强了数据库的扩展能力

* 不遵循SQL标准
* 不支持ACID
* 远超于SQL性能

## 2、适用场景

* 对数据高并发读写
* 海量数据读写
* 对数据高扩展性

## 3、不适用场景

* 需要事务支持
* 基于SQL结构化查询存储，处理复杂的关系

## 4、为什么要用NoSql

web2.0 时代

![](..\images\redis1.png)

### 1、解决CPU及内存压力

![](..\images\redis2.png)

采用nginx负载均衡，做成分布式，多个请求分发到不同服务器，缓解服务器压力。

但会带来一个问题：

session（存放用户信息）是存在服务器A中，但第二次请求可能会到服务器B中

所以建议采用NOSQL，不需要经过IO操作

### 2、解决IO压力

![](..\images\redis3.png)

## 5、行式数据库

![](..\images\redis4.png)

## 6、列式数据库

![](..\images\redis5.png)

## 7、多样化的数据结构存储持久化数据

![](..\images\redis6.png)

![](..\images\redis7.png)

# 二、安装启动

```shell
cd /opt/
wget https://download.redis.io/releases/redis-6.2.2.tar.gz
gcc --version
tar -zxvf redis-6.2.2.tar.gz
cd redis-6.2.2/
// 编译成C文件
make
// 安装
make install
// 默认安装到此路径
cd /usr/local/bin/
```

![](..\images\redis8.png)

不推荐使用前台启动，因为窗口关闭，服务器停止

把redis-6.2.2下的redis.conf 拷贝到 /etc目录下，并修改/etc下的参数daemonize为yes

```shell
cd /usr/local/bin/
redis-server /etc/redis.conf
// 通过客户端连接redis 
ps -ef|grep redis 
// 看到 redis-server 127.0.0.1:port


redis-cli -p [port] -a [password]
// 也可以这样输入密码
auth [password]

//　关闭
shutdown
```

docker 版本

```sh
docker pull redis:latest
```

```yml
version: "3.5"

services:
  ## ======================= Redis(v6.2.4) =========================
  redis:
    image: redis:latest
    network_mode: host
    command:
      [ "redis-server", "/data/conf/redis.conf" ]
    restart: always
    container_name: redis
    hostname: redis.lmc.top
    volumes:
      - /etc/localtime:/etc/localtime
      - ./data:/data
    healthcheck:
      test: ["CMD-SHELL","redis-cli -a [password] -p [port] ping"]
      interval: 30s
      timeout: 10s
      retries: 6
      start_period: 40s

```

## 1、基础知识

默认16个数据库，从0开始，默认使用0号库，所有库密码相同

```shell
// 切换
select [index]
```

### 1）单线程+多路IO复用

Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

![](..\images\redis9.png)
但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。

这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是，socket 网络模型本身支持非阻塞模式。

# 三、五大数据类型

![](..\images\redis10.png)

## 1、String

### 1）简介

String类型是**二进制安全的**，可以包含任何数据，比如jpg图片或者序列化对象

一个Redis中字符串value最多可以是**512M**

### 2）常用命令

```shell
// 添加键值对
set <key> <value>
// 查询对应键值
get <key>
// 将给定的value追加到原值的末尾
append <key> <value>
// 获得值的长度
strlen <key>
// 只有在key不存在时，设置key的值
setnx <key> <value>
// 将key中储存的数字值增减1.只能对数字值操作，如果为空，新增值为1/-1
incr/decr <key>
// 将key中储存的数字值增减，自定义步长
incrby/decrby <key> <步长>
// 同时设置一个或多个key-value对
mset <key1> <value1> <key2> <value2>...
// 同时获取一个或多个value
mget <key1><key2><key3>
// 同时设置一个或多个key-value对，当且仅当所有给定key都不存在，有一个失败，则都失败
msetnx <key1> <value1> <key2> <value2>...

// 获得值的范围，类似Java中的substring，前包，后包
getrange <key><起始位置><结束位置>

// 用<value>覆写<key>所存储的字符串值，从<起始位置>开始（索引从0开始）
setrange <key> <起始位置> <value>

// 设置键值的同时，设置过期时间，单位秒
setex <key><过期时间><value>

// 以新换旧，设置了新值同时获得旧值
getset <key> <value>

// 查看剩余有效时间
ttl <key>
```

incrby 和 decrby 都是原子性操作

![](..\images\redis12.png)

**案例：**

![](..\images\redis11.png)

### 3）数据结构

![](..\images\redis13.png)

![](..\images\redis14.png)

## 2、List

### 1）简介

![](..\images\redis15.png)

### 2）常用命令

![](..\images\redis16.pn)

![](..\images\redis17.png)

### 3）数据结构

![](..\images\redis18.png)

## 3、Set

### 1）简介

![](..\images\redis19.png)

![](..\images\redis20.png)

### 2）常用命令

![](..\images\redis21.png)

![](..\images\redis22.png)

## 4、Hash

### 1）简介

![](..\images\redis23.png)

![](..\images\redis24.png)

### 2）常用命令

![](..\images\redis25.png)

### 3）数据结构

![](..\images\redis26.png)

## 5、Zset

### 1）简介

![](..\images\redis27.png)

### 2）常用命令

![](..\images\redis28.png)

![](..\images\redis29.png)

### 3）数据结构

![](..\images\redis30.png)

## 6、新数据类型-Bitmaps

## 7、Streams

专门用来为消息队列设计的数据类型：

* XADD：插入消息，保证有序，可以自动生成全局唯一 ID
* XRED：读取消息，可以按 ID 读取
* XREADGROUP：按消费组形式读取消息
* XPENDING 和 XACK：XPENDING 用来查询每个组内所有消费者已读取但未确认的消息，XACK 用于向消息队列确认消息处理已完成。

![](..\images\redis83.png)

# 四、配置文件

配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感

```shell
vim /etc/redis.conf
```

## 1、Units 单位

![](..\images\redis31.png)

## 2、NETWORK 网络

### 1）bind 127.0.0.1 -::1

将此行注释掉，表示允许访问的端口

### 2）protected-mode yes

改为no，表示禁用***本机访问保护模式***

### 3）tcp-backlog

![](..\images\redis32.png)

# 五、发布和订阅

## 1、定义

Redis 发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息

Redis 客户端可以定义任意数量的频道

![](..\images\redis33.png)

## 2、命令行

1）打开一个客户端订阅channel1

![](..\images\redis34.png)

2）打开**另一个客户端**，给channel1发布消息 hello，返回的1是订阅者数量

![](..\images\redis35.png)

3）打开第一个客户端可以看到发送的消息

![](..\images\redis36.png)

# 六、Jedis

## 1、常用操作

```java
        // 创建Jedis对象
        String value;
        try (Jedis jedis = new Jedis("172.16.15.160", 6379)) {
            // 测试是否能拼通
            value = jedis.ping();
        }
        System.out.println(value);
```

## 2、实例：手机验证码

![](..\images\redis37.png)

# 七、事务与锁

## 1、基本概念

![](..\images\redis38.png)

![](..\images\redis39.png)

![](..\images\redis40.png)

![](..\images\redis41.png)

![](..\images\redis42.png)

![](..\images\redis43.png)

![](..\images\redis44.png" style="zoom: 50%;" />

![](..\images\redis45.png)

![](..\images\redis46.png)

在执行multi之前，先执行watch key1 [key2]，可以监视一个（或多个）key，如果在事务执行这个（或这些）key被其他命令所改动，那么事务将被打断

![](..\images\redis48.png)

unwatch：取消watch命令对所有key的监视

![](..\images\redis47.png)

## 2、并发模拟

```shell
yum install httpd-tools
ab --help
# 1000个请求中有100个是并发操作
ab -n 1000 -c 100 http://172.23.23.234:8080/redisTest/miaosha
```

## 3、超卖问题

![](..\images\redis49.png)

## 4、库存遗留

![](..\images\redis50.png)

![](..\images\redis51.png)

# 八、持久化操作

## 1、RDB

在指定**时间间隔内**将内存中的数据集**快照**写入磁盘

配置文件，设置持久化规则：

```shell
vim /etc/redis.conf
```

在 /usr/local/bin 中可以查看 dump.rdb 大小

save：只管保存，其他不管，全部阻塞。手动保存。不建议

bgsave：Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

![](..\images\redis52.png)

## 2、AOF

### Append Only File

**以日志的形式来记录每个写操作（增量保存）**，将redis执行过的所有写指令记录下来 **（读操作不记录），只许追加文件但不可以改写文件**，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就可以根据日志文件的内容将写指令从前到后执行一次完成数据恢复的工作。

写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。

![](..\images\redis54.png)

### aof 默认不开启

可以在redis.conf 中配置文件名称，默认为 appendonly.aof

保存路径和RDB一致

**AOF和RDB同时开启，系统默认取AOF的数据（数据不会丢失）**

### 异常恢复

1）修改默认的appendonly no，改为 yes

2）如遇到AOF文件损坏，通过命令恢复

```shell
/usr/local/bin/redis-check-aof--fix appendonly.aof
```

3）备份被损坏的aof文件

4）重启redis

### 同步频率设置

![](..\images\redis53.png)

### 优劣势

![](..\images\redis55.png)

# 九、主从复制

主机数据更新后根据配置和策略，自动同步到备机的**master/slaver机制，Master以写为主，Slave以读为主**

注：主服务器只能有一台，如果有两台，第一台 set a1 v1 ，第二台  set a1 v11，那么从服务器复制时，到底听谁的？

![](..\images\redis56.png)

如果之前是从第一台服务器读数据，但突然第一台挂了，可以切换到读第二台的数据

## 1、搭建

![](..\images\redis57.png)

```shell
# 启动redis
redis-server redis63**.conf
# 指定端口打开redis客户端
redis-cli -p port
# 设置为 目标 服务器的从
slaveof [目标]ip port
# 查看主从信息
info replication
```

如果**从服务器**挂了，重启并不会自动加入原有的主从关系，需要手动加入，然后会自动复制主服务器的所有数据

如果主服务器挂了，小弟并不会上位，会显示大哥挂了

## 2、原理

![](..\images\redis58.png)

 ![](..\images\redis59.png)

## 3、反客为主

当一个master宕机后，后面的slave可以立刻升为master

把从机变成主机：

```shell
slaveof no one
```

## 4、哨兵模式

反客为主的自动版

```sh
cd myredis/
# 创建配置文件
vim sentinel.conf
# 启动
redis-sentinel sentinel.conf
```

![](..\images\redis60.png)

![](..\images\redis62.png)

当主机挂掉，从机选举中产生新的主机，大概10秒左右可以看到哨兵窗口日志，切换了新的主机

根据优先级别：slave-priority（高版本为replica-priority），来选择新主机

**原主机重启后会变成从机**

原主机挂掉后，哨兵输出日志：

![](..\images\redis61.png)

# 十、集群

## 1、无中心化

![](..\images\redis63.png)

![](..\images\redis64.png)

## 2、优缺点

![](..\images\redis65.png)

# 十一、应用问题

## 1、缓存穿透

![](..\images\redis70.png)

产生原因：应用服务器压力变大，正常应该是先查缓存，查到就返回，查不到再查数据库，放到缓存中，但由于大量数据在redis中查不到，数据库不断进行IO操作，导致缓存穿透

解决方案：

![](..\images\redis66.png)

![](..\images\redis67.png)

## 2、缓存击穿

![](..\images\redis68.png)

![](..\images\redis69.png)

![](..\images\redis72.png)

![](..\images\redis71.png)

## 3、缓存雪崩

![](..\images\redis73.png)

![](..\images\redis74.png)

![](..\images\redis75.png)

![](..\images\redis76.png)

# 十二、分布式锁

## set NX PX + Lua

**加锁**： set NX PX + 重试 + 重试间隔

向Redis发起如下命令: `SET productId:lock 0xx9p03001 NX PX 30000`

其中，"productId"由自己定义，可以是与本次业务有关的id，"0xx9p03001"是一串随机值，必须保证全局唯一。

“NX"指的是当且仅当key(也就是案例中的"productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。

"PX 30000"指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁


## Redlock

在分布式系统中，网络分区可能导致某些节点失去连接，从而无法释放锁。这时可能需要使用更复杂的分布式锁算法，如 Redlock。

Redlock 是一种由 Redis 作者提出的分布式锁算法，它旨在解决单个 Redis 实例可能出现的可靠性问题。Redlock 通过在多个独立的 Redis 实例上获取锁来确保分布式系统的安全性和可靠性。


### 基本步骤

#### 获取锁

* 在N个 Redis 实例上尝试获取锁
* 为每个锁设置一个相同的过期时间
* 尝试在每个 Redis 实例上以非阻塞的方式（使用 NX 选项）获取锁
* 如果在一半的实例（N/2+1个）上成功，则认为获取锁成功

#### 验证锁有效性

* 获取锁成功后，验证实际消耗时间是否小于锁过期时间，如果超过，认为锁获取失败

#### 释放锁

* 在所有实例上释放锁（使用 Lua 脚本保证原子性，确保只有持有锁的客户端才能释放锁）

### 自动续签

Redisson 的 Watchdog 是一个后台线程，它会在锁持有期间定期检查锁的状态并自动续签，以确保锁在持有期间不会过期。默认情况下，Redisson 会在锁的持有时间达到过期时间的一半时进行续签。


# 十三、acl

## 1、规则

![](..\images\redis81.png)

![](..\images\redis82.png)

```shell
# 展现用户权限列表
acl list
# 添加用户
acl setuser lucy
# 查看当前用户
acl whoami
```



## 分布式锁

学习分布式锁之前，应该先了解线程锁，进程锁。

### 线程锁

用来给方法、代码块加锁。同一时刻仅有一个线程执行该方法或者该代码段。线程锁只在同一个JVM中有效果，**因为线程锁的实现在根本上是依靠线程之间共享内存实现的**，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）

### 进程锁

为了控制**同一操作系统**中多个进程访问某个共享资源，因为进程具有**独立性**，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。

### 分布式锁

多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问

### 基于数据库实现分布式锁

#### 悲观锁

使用了 `select…for update`的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改

#### 乐观锁

使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号

### 基于 Redis 实现

## 3、持久化

### 为什么需要持久化

Redis 基于内存，服务一旦宕机，内存中的数据全部丢失，如果从后端数据库恢复数据，大数据量下对数据库的压力太大，且性能差，导致程序响应慢
所以实现Redis数据持久化，避免从后端数据库中恢复数据

### RDB

> Redis DataBase 的缩写，中文名为内存快照，把**当前进程数据**生成快照保存到磁盘上，由于是**某一时刻**的快照，快照中的值要早于或等于内存中的值
> 是Redis的默认持久化方式

#### 手动触发

* save 命令：阻塞当前Redis服务器，直到RDB过程完成，对于内存较大的实例会造成长时间阻塞，线上环境不建议使用
* bgsave 命令：Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短

![](..\images\redis-bgsave.png)
1）触发bgsave命令
2）主进程判断当前**是否已经存在正在执行的子进程**，如果存在，主进程直接返回
3）如果不存在，就fork一个新的子进程进行持久化数据，**fork过程是阻塞的**，fork操作完成后主进程即可执行其他操作
4）子进程先将数据写入到**临时的rdb文件**中，待快照数据写入完成后再**原子替换旧的rdb文件**
5）**同时**发信号给主进程，通知主进程rdb持久化完成，主进程更新相关统计信息

#### 自动触发

> 在以下4中情况会自动触发

* 设置**快照周期**：redis.conf 中配置 `save m n`，即m秒内有n次修改时，自动触发bgsave生成rdb文件
* 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点
* 执行 debug reload 命令重新加载 redis 时也会触发 bgsave 操作
* 执行 shutdown 命令时，如果没有开启 aof 持久化，也会触发 bgsave 操作

#### 实战

1、由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？

核心思路是Copy-on-Write，来保证进行快照操作的这段时间，需要写入磁盘的数据在内存中不会发生变化。
一方面Redis主进程会fork一个新的快照进程来专门做这个事情，这样保证了Redis服务**不会停止对客户端包括写请求在内的任何响应**。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。

![](..\images\redis-x-aof-42.jpg)

2、在进行快照操作这段时间，服务崩溃怎么办

在没有将数据全部写入磁盘之前，这次快照操作都不算成功，如果服务崩溃，将以**上一次完整的RDB快照文件**作为恢复内存数据的参考，也就是说在操作快照过程中不能影响上一次数据备份，操作成功后，才会用这个临时文件替换掉上一次的备份

3、可以每秒做快照吗
不建议，虽然bgsave不阻塞主线程，但是如果频繁的执行**全量快照，会带来两方面的开销**

* 磁盘压力大
* fork 创建的过程会阻塞主线程

#### RDB 优缺点

* 优点
  * 压缩后的文件体积小，适用于备份、全量复制
  * redis 加载Rdb文件恢复速度比 AOF 快
* 缺点
  * 实时性不够
  * fork子进程成本高
  * rdb文件不可读

### AOF

> Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

![](..\images\redis-x-aof-4.jpg)

1. 开启aof备份方式

```shell
./redis-cli -h 172.23.26.78 -p 6999
config set appendonly yes
```

可以看到对应路径下的aof文件生成
2. 同步

```shell
./redis-cli -h 172.23.26.23 -p 6999 --pipe < appendonly.aof
```

## 4、有哪些集群模式

### 主从复制

> 指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点

#### 作用

* 数据备份：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式
* 故障恢复：当主节点出现问题，可以由从节点提供服务
* 负载均衡：写Redis数据时应用连接主节点，读Redis数据时应用连接从节点，分担服务器负载

![](..\images\db-redis-copy-1.png)

#### 主从复制原理

##### 确立主从关系

在从机上执行：

```shell
replicaof ip port
```

![](..\images\db-redis-copy-2.jpg)

##### 全量复制

1）主从库建立连接，协商同步
2）主库执行bgsave命令，生成RDB文件，将文件发给从库，从库接收到RDB文件，先清空当前数据库，然后加载 RDB 文件；
在**主库同步数据给从库**的过程中，可能产生新写的数据，这些数据并没有记录到刚刚生成的RDB文件中，为了保证主从库数据一致性，主库会在内存中用专门的 replication buffer，记录RDB文件生成后收到的所有写操作
3）把replication buffer中的修改操作发送给从库，让**从库再执行这些操作**

##### 增量复制

* 为什么会设计增量复制？
  如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步
* 增量复制的流程

##### 当主服务器不进行持久化时复制的安全性

> 在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，避免将实例配置为自动重启

假如节点B和C从节点A复制数据，这时出现了一个崩溃，但Redis具有自动重启系统的功能，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集

由于A是空的，B、C从节点A进行复制，所以B、C上复制的数据也会被删除

##### 为什么全量复制使用RDB而不是AOF

1、RDB是经过压缩的二进制数据，文件很小，而AOF文件记录的是每一次写操作命令，写操作越多文件就越大。从库在加载RDB文件时，读取整个文件的速度会很快，而且由于是二进制数据，从库直接按照RDB协议解析还原即可。

AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑。

2、如果使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘策略，选择不当会严重影响Redia性能。而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。

### 哨兵机制

如果在主从复制的时候，主节点出现故障怎么办？在Redis主从集群中，哨兵机制是实现主从库自动切换的关键机制，他有效的解决了主从复制模式下**故障转移**的问题

#### 哨兵的功能

![](..\images\db-redis-sen-1.png)

* 监控：哨兵会不断的**检查**主节点和从节点是否运作正常
* 自动故障转移：当主节点不能正常工作时，哨兵会将**其中一个从节点**升级为新的主节点，并让其他从节点改为复制新的主节点
* 配置提供者：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址
* 通知：哨兵可以将故障转移的结果发送给客户端

#### 哨兵集群的组建

> 哨兵实例之间可以相互发现，要归功于Redis提供的 pub/sub 机制

主从集群中，主库有一个名为 `__sentinel__:hello`的频道，不同哨兵就是通过它来相互发现，实现互相通信的。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到 `__sentinel__:hello`频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。

![](..\images\db-redis-sen-6.jpg)

#### 哨兵监控Redis库

哨兵2给**主库**发送INFO命令，主库接受到这个命令后，就把**从库列表**返回给哨兵。

接着，哨兵就可以根据从库列表中的连接信息，和每个从库**建立连接**，并在这个连接上**持续地**对从库进行监控。

![](..\images\db-redis-sen-7.jpg)

#### 主库下线的判定

* 主观下线：任何一个哨兵都可以监控探测，并作出Redis节点下线的判断
* 客观下线：由哨兵集群共同决定Redis节点是否下线

当某个哨兵判断主库 `主观下线`后，就会给其他哨兵发送命令，其他哨兵会根据自己和主库连接的情况，做出Y或N的响应。如果赞成票数大于等于哨兵配置文件的quorum配置项，就可以判断**主库客观下线**了

#### 哨兵集群的选举

由于哨兵分布式集群，有多个节点；故障转移通知都只需要一个主节点的哨兵就行

通过Raft选举算法，选出领导者，领导者必须满足两个条件

* 拿到半数以上的赞同票
* 拿到的票数同时还需要大于等于哨兵配置文件中的quorum值

#### 新主库的选出

从剩下的从库中选择一个新的主库

* 过滤掉下线的：没有回复过哨兵ping响应的从节点
* 选择 salve-priority 从节点优先级最高的
* 选择复制偏移量最大的（复制最完整的从节点）

#### 故障的转移

新的主库选出来之后，就可以进行故障的转移了

* slave-1脱离从节点，升级为主节点
* 将从节点slave-2指向新的主节点
* 通知客户端主节点已更换
* 将原主节点变成从节点，指向新的主节点

## 5、过期键清除策略

* 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除
* 定期删除：服务器执行定时任务删除过期数据，但考虑到内存和CPU（删除会释放内存，但频繁删除操作对CPU不友好），该删除的频率和执行时间都受到限制

## 6、rehash 的过程

## 7、性能优化

1、网络带宽过载，网络IO瓶颈
2、使用Swap（操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域），当内存中的数据被换到磁盘上后，Redis 再访问这些数据时，就需要从磁盘上读取，访问磁盘的速度要比访问内存慢几百倍

## 8、事务

事务的本质是一组命令的集合，在事务执行过程，会按照**顺序串行**执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中

* MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。
* XEC：执行事务中的所有操作命令。
* DISCARD：取消事务，放弃执行事务块中的所有命令。
* WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。
* UNWATCH：取消WATCH对所有key的监视。

### 事务错误的处理

* 语法错误（编译错误）
  在开启事务后，修改k1值为11，k2值为22，但k2语法错误，最终导致事务提交失败，k1、k2保留原值
* Redis类型错误（运行时错误）
  在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，此时事务并没有回滚，而是跳过错误命令继续执行， 结果k1值改变、k2保留原值

### CAS 实现乐观锁

> WATCH 命令可以为 Redis 事务提供 check-and-set 行为

被 watch 的键会被监视，如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败
程序需要做的就是不断重试这个操作，直到没有发生碰撞为止

![](..\images\db-redis-trans-2.png)

### 如何理解Redis与事务的ACID

* 原子性atomicity
  Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行。而不是完全成功。
* 一致性consistency
  redis事务可以保证命令失败的情况下得以回滚，数据能恢复到没有执行之前的样子，是保证一致性的，除非redis进程意外终结
* 隔离性Isolation
  redis事务是严格遵守隔离性的，原因是redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断。

但是，Redis不像其它结构化数据库有隔离级别这种设计。

* 持久性Durability
  redis事务是不保证持久性的，这是因为redis持久化策略中不管是RDB还是AOF都是异步执行的，不保证持久性是出于对性能的考虑

## 9、缓存问题：一致性、穿透、雪崩等

## 缓存穿透

**缓存和数据库中都没有的数据**，由于缓存查不到每次都会再查数据库，对数据库影响极大。

比如id为-1这种不存在的数据，很可能是攻击者

### 解决方案

* 接口增加校验，比如根据id做基础校验
* 从缓存、数据库中都没有取到的数据，可以将这个key设置30秒有效，防止攻击者反复用同一个id暴力攻击
* 布隆过滤器：用于快速判断某个元素是否存在于集合中

## 缓存击穿

**缓存中没有但数据库中有**（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又大量请求进了数据库，造成数据库压力过大

### 解决方案

* 设置热点数据永不过期
* 接口限流与熔断，降级。

## 缓存雪崩

缓存雪崩是指缓存中**数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机**。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库

## 缓存和数据库一致性

![](..\images\db-redis-cache-1.jpg)

读取缓存一般没问题，但数据更新时，**无论是先写数据库再删Redis缓存，还是先删缓存再写库，都可能出现数据不一致的情况**，举例

1、如果删除了Redis缓存，还没来得及写库，另一个线程就来读取，发现缓存为空，就去数据库中读取数据写入缓存，此时缓存中为脏数据
2、如果先写了库，在删除缓存前，写库的线程宕机了，没有删掉缓存，也会出现数据不一致的情况
因为，写和读是并发的，没法保证顺序，就会出现缓存和数据库不一致的情况

### 方案

* 读的时候：先读缓存，缓存没有的话，就读数据库，然后取出数据放入缓存，同时返回响应
* 更新的时候：先更新数据库，然后再删除缓存

逻辑：

* 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中
* 命中：应用程序从cache中取数据，取到后返回
* 更新：先把数据存到数据库中，成功后，再让缓存失效