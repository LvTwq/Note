# 一、如何设计一个高可用系统

高可用系统是确保服务面临可能故障仍可以持续稳定运行，目标是最大限度减少停机时间。

## 1. 冗余设计

* 多副本部署：应用服务器、数据库，应该部署多个副本，避免单点故障
* 跨区域部署：将服务部署在不同物理位置，防止单一区域故障导致服务中断

## 2. 负载均衡

* 使用负载均衡器，例如Nginx，将流量分发到多个后端服务器，避免单台服务器过载
* 支持健康检查，自动剔除故障节点，保障流量只转发到健康的实例

## 3. 健康检查

* 自动故障转移：当主节点故障时，自动切换到备节点（例如数据库、redis主从切换）
* 自我修复：容器的健康检查机制，自动重启


## 4. 数据备份

* 数据副本：确保数据在多个节点同步
* 定期备份：通过定时任务，定期全量/增量备份


## 5. 弹性与可扩展性

* 水平扩展：通过增加实例数量应对流量增长
* 无状态服务：尽量将应用设计为无状态（状态存储在外部数据库或redis），便于扩展和故障恢复


## 6. 监控与告警

* 全面监控：监控系统指标（CPU、内存、磁盘、网络）、应用性能（响应时间、错误率）和业务指标（登录失败）
* 实时告警：自动通知运维人员


## 7. 容错、降级、限流

* 熔断：当依赖服务故障时，快速失败并返回默认值
* 降级：关闭非核心服务
* 限流：令牌桶、IP限流



## 8. 设计原则

* 假设一切都会失败
* 最小依赖化
* 混沌工程





# 二、如何设计一个高并发系统

高并发系统是为了面对大量用户同时访问时，依然能够稳定运行。

## 1. 系统架构设计

### a. 分层架构

接入层、应用层、服务层、数据层，便于水平扩展


### b. 微服务化

* 将单体应用拆分为多个微服务，每个服务可独立部署、扩展

### c. 无状态设计

* 应用服务尽量设计为无状态，例如用户会话存储在redis，便于水平扩展


## 2. 性能优化

### a. 缓存策略

* 多级缓存
* 防止缓存穿透、击穿、雪崩

### b. 异步处理

* 使用消息队列解耦系统，异步化业务
* 提升响应速度，削峰填谷

### c. 数据库优化

* 索引优化
* 连接池
* 读写分离
* 分库分表


## 3. 横向扩展

* 应用层：通过负载均衡，将请求分发到多个应用实例
* 服务层：微服务按需自动伸缩
* 数据层：使用分布式数据库


## 4. 容错、降级、限流

* 熔断：当依赖服务故障时，快速失败并返回默认值
* 降级：关闭非核心服务
* 限流：令牌桶、IP限流

## 5. CDN与静态资源优化

* 将静态资源托管到CDN，减轻源站压力
* 启用Gzip、HTTP/2、资源合并等前端优化手段


## 6. 监控

* 全面监控：监控系统指标（CPU、内存、磁盘、网络）、应用性能（响应时间、错误率）和业务指标（登录失败）
* 实时告警：自动通知运维人员

# 三、生产环境突发大流量导致服务不可用

## 第一阶段：快速恢复服务

* 先安抚客户，研发团队已经接入
* 确认现象：

  * 全部用户还是部分用户/区域（网络分区问题？）
  * 完全无法访问（502、504），还是部分接口超时
  * 关注监控指标：系统资源（CPU、内存、IO、带宽、数据库连接数）
* 定位瓶颈：

  * 入口层：nginx是否过载，连接数到达上限
  * 应用层：应用服务器的cpu、内存是否打满？
  * 依赖层：数据库（连接池满、慢SQL、死锁、主从延迟）、redis是否有大key
  * 网络层：带宽是否跑满？DDoS？
* “止血”措施：

  * 紧急扩容：增加服务实例
  * 流量管控：
    * 限流：直接对特定IP限流（iptables）
    * 降级：关闭非核心功能
    * 熔断：如果没有依赖服务已经不可用，则快速失败，避免雪崩（逃逸模式）
  * 数据库应急：
    * kill慢查询
    * 临时增加连接数
    * 读写分离
  * redis应急：
    * 手动删除大key
    * 手动加载某个key

## 第二阶段：定位根本原因

* 数据收集：
  * 监控数据：CPU、内存、数据库
* 日志分析：
  * 慢查询/死锁：优化sql
  * nginx日志：哪个接口qps最高
  * 应用日志：不合理的操作（死循环、资源未释放）
  * redis：大key、缓存雪崩、击穿
  * 爬虫攻击：user-agent、ip是否集中


# 四、多租户改造

## 1. 三种模式

* 独立数据库
* 共享数据库，独立schema
* 共享数据库，共享表，通过tenant_id 字段区分

## 2. 核心步骤

### a. 租户识别

请求进入系统时，识别当前请求属于哪个租户，塞进上下文，通过 `ThreadLocal` 实现

* 子域名
* url路径
* HTTP header

### b. 动态数据源切换

* MyBatis 拦截器自动加 `tenant_id`


## 3. 缓存多租户隔离

* Redis 中 Key 应包含 `tenant_id`


## 4. 权限控制

有一个全局过滤器校验当前访问接口是否属于当前 tenant_id


## 5. 日志

* 日志中记录tenant_id
