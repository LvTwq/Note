[toc]

## 介绍一下你的项目，其中有哪些技术栈

前端框架使用的是Vue

后端框架使用的Spring全家桶。

我们的系统通常都会有登录的功能模块，多个相关系统的话就会涉及到单点登录，我们基于CAS协议实现了单点登录

系统中有很多数据属于热点数据，通常又不会发生变化，如果每次从数据库中查的话，会比较影响性能，所以引入了缓存机制，如果是规模比较小的项目，就直接使用spring-cache，规模大的系统会引入redis中间件。

最终提供出来的功能页面可能是由多个系统组成的，那就涉及到了跨域的问题，通常通过nginx的反向代理来解决。

nginx除了反向代理，还提供了负载均衡的能力，负载均衡是高可用的一种解决方案。

数据库使用的是 PostgreSQL ，数据库的安装使用并不难，对于我们开发来说，最重要的还是性能，不允许有慢SQL，往往会使用索引来优化查询速度。







# 开放类问题

## 1、介绍一下你最近参与或印象最深的一个项目。在项目中，你主要负责了哪些模块？遇到了哪些技术挑战？你是如何分析和解决这些问题的？

零信任安全接入平台，是为了替换传统VPN，实现更安全的远程办公。需要支持数万用户，数十万终端设备的并发接入，对系统高可用、高并发处理能力、审计合规性要求极高。

我参与了多个核心模块的开发，其中，亿级日志审计系统是我面临的最大技术挑战之一。

挑战：每天需要处理数万用户、数十万终端的操作日志、访问日志。峰值写入量超过3w条/s。

最早的方案，使用MySQL按天分表存储，查询时多线程查询再合并。应对小局点绰绰有余，但应对大局点1kw的单表数据，已经超过了MySQL的上限。

于是转向了传统ELK方案，但es的问题在于，存储成本昂贵，并且对内存的要求极高，因为es需要大量内存来缓存倒排索引，内存不足容易影响性能甚至oom。

并且es虽然擅长全文检索，但我们的数据都是结构化的，我们需要的是对海量数据进行复杂的聚合、统计，查询时通常只关注部分字段，所以并没有完全发挥es的优势。

于是我们把目光转向了clickhouse。

ch的写入性能极高，用MergeTree引擎，对时间字段进行分区排序，提高了写入和查询性能。

ch由于是列式存储，有极高的压缩比，同样的一亿条数据，压缩后，ch只需要2.5G，但es需要20G。

对于按照字段聚合查询，哪怕是亿级数据，ch也能毫秒级返回结果。





## 2、做过什么创新性工作

ai审计代码

## 3、系统中哪个功能是有成就感的

## 4、为什么想来我们公司

## 5、只给你一个微服务网关怎么优化并发

单体应用拆成多个微服务之后，需要有网关作为外部请求和内部服务之间的流量入口，实现对外部请求的鉴权，校验，监控等通用功能

高并发实现的三板斧：缓存，限流和降级

### 缓存

应用系统和数据库要做IO操作，有性能瓶颈。所以往往引入缓存。
比如
1、网关加载缓存模块，根据请求URL和参数解析，从网关缓存查询
2、如果缓存命中，那么返回命中的值
3、如果缓存未命中，那么请求真正的API服务提供者
4、请求结果返回网关
5、网关将请求结果缓存
但要注意，缓存穿透、雪崩的问题。

### 限流

每个系统都有上限，当流量超过服务上限的时候，系统会出现卡死，崩溃的情况。
那么当瞬时高并发时，为了保证系统的稳定可用，以牺牲部分请求或者延迟处理请求为代价，保证系统整体服务可用。

#### 令牌桶（Token Bucket）

> 现有一个木桶，系统按照固定速度，往桶里加Token，如果桶已经满了就不再添加；
> 当有请求到来时，会各自拿走一个Token，取到Token才能继续进行处理，没有Token就拒绝服务。
> 如果一段时间没有请求，桶内就会积累一些Token，下次一旦有突发流量，只要Token足够，也能一次处理。

Guava RateLimiter 提供了实现

#### 漏桶

水（请求）先进入到漏桶里，漏桶以一定的速度出水（接口有响应速率），当水流入速度过大会直接溢出（**访问频率超过接口响应速率**），即拒绝请求，可以看出漏桶算法能强制限制数据的传输速率。

#### 计数器方式

限制**总并发数**，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。也是最简单粗暴的算法

##### 采用 AtomicInteger

使用 AtomicInteger 来统计正在执行的次数，如果超过阈值就直接返回“系统繁忙”
但有个弊端，可能只是瞬时的请求量高，造成误伤。

##### 采用ThreadPoolExecutor线程池

固定线程池大小，超出最大线程数，则拒绝请求。

### 降级/熔断

> 高并发环境下，服务之间的依赖关系导致调用失败，通常解决方式：限流->熔断->隔离->降级, 其目的是防止雪崩效应

写降级：先只更新缓存，然后异步更新数据库，保证最终一致性，这里是把DB降级为Cache
读降级：对读一致性不高的场景，只读缓存
