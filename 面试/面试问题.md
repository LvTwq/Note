[toc]


## 3、介绍一下你的项目，其中有哪些技术栈

前端框架使用的是Vue

后端框架使用的Spring全家桶。

我们的系统通常都会有登录的功能模块，多个相关系统的话就会涉及到单点登录，我们基于CAS协议实现了单点登录

系统中有很多数据属于热点数据，通常又不会发生变化，如果每次从数据库中查的话，会比较影响性能，所以引入了缓存机制，如果是规模比较小的项目，就直接使用spring-cache，规模大的系统会引入redis中间件。

最终提供出来的功能页面可能是由多个系统组成的，那就涉及到了跨域的问题，通常通过nginx的反向代理来解决。

nginx除了反向代理，还提供了负载均衡的能力，负载均衡是高可用的一种解决方案。

数据库使用的是 PostgreSQL ，数据库的安装使用并不难，对于我们开发来说，最重要的还是性能，不允许有慢SQL，往往会使用索引来优化查询速度。

# 开放类问题

## 1、工作中遇到过什么困难吗

## 2、做过什么创新性工作

经常会有这样的业务场景，用户、单位、状态 存到库里基本是code，但页面上需要展示他的中文名，有的时候既需要中文又需要code。
最简单的做法是，从数据库里拿到id之后，再去另一张表中查出这个id对应的中文。
但这样带来几个问题：
1、这些映射数据是不会轻易变更的，是一个典型的读多写少的场景，很适合引入缓存，读数据库有io开销，性能是要弱于读缓存的，缓存是用 spring cache 做的内存缓存
2、把读库换成读缓存之后，性能虽然上去了，但每次都要写一段和当前业务逻辑没什么关系的代码，而且这段代码是高度相似的，那就可以用面向切面编程的思想，把它分离出去。

在实体上要翻译的字段添加 @CodeType 注解，代表这个字段要被按照哪种类型翻译，方法上添加 @DataConvert 注解，并且方法的返回值是这个实体，我要对这个方法进行环绕处理。
为这个方法做切面，拿到实体后，遍历字段，从缓存中拿到翻译后的值，再用反射调用这个字段的set方法，给他赋值，遍历完毕。

## 3、系统中哪个功能是有成就感的

## 4、为什么想来我们公司

## 5、只给你一个微服务网关怎么优化并发

单体应用拆成多个微服务之后，需要有网关作为外部请求和内部服务之间的流量入口，实现对外部请求的鉴权，校验，监控等通用功能

高并发实现的三板斧：缓存，限流和降级

### 缓存

应用系统和数据库要做IO操作，有性能瓶颈。所以往往引入缓存。
比如
1、网关加载缓存模块，根据请求URL和参数解析，从网关缓存查询
2、如果缓存命中，那么返回命中的值
3、如果缓存未命中，那么请求真正的API服务提供者
4、请求结果返回网关
5、网关将请求结果缓存
但要注意，缓存穿透、雪崩的问题。

### 限流

每个系统都有上限，当流量超过服务上限的时候，系统会出现卡死，崩溃的情况。
那么当瞬时高并发时，为了保证系统的稳定可用，以牺牲部分请求或者延迟处理请求为代价，保证系统整体服务可用。

#### 令牌桶（Token Bucket）

> 现有一个木桶，系统按照固定速度，往桶里加Token，如果桶已经满了就不再添加；
> 当有请求到来时，会各自拿走一个Token，取到Token才能继续进行处理，没有Token就拒绝服务。
> 如果一段时间没有请求，桶内就会积累一些Token，下次一旦有突发流量，只要Token足够，也能一次处理。

Guava RateLimiter 提供了实现

#### 漏桶

水（请求）先进入到漏桶里，漏桶以一定的速度出水（接口有响应速率），当水流入速度过大会直接溢出（**访问频率超过接口响应速率**），即拒绝请求，可以看出漏桶算法能强制限制数据的传输速率。

#### 计数器方式

限制**总并发数**，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。也是最简单粗暴的算法

##### 采用 AtomicInteger

使用 AtomicInteger 来统计正在执行的次数，如果超过阈值就直接返回“系统繁忙”
但有个弊端，可能只是瞬时的请求量高，造成误伤。

##### 采用ThreadPoolExecutor线程池

固定线程池大小，超出最大线程数，则拒绝请求。

### 降级/熔断

> 高并发环境下，服务之间的依赖关系导致调用失败，通常解决方式：限流->熔断->隔离->降级, 其目的是防止雪崩效应

写降级：先只更新缓存，然后异步更新数据库，保证最终一致性，这里是把DB降级为Cache
读降级：对读一致性不高的场景，只读缓存
