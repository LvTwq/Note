[TOC]



## 原理

### 一、哈希

![](images\Git原理.png)

底层采用 SHA-1 算法，比对加密后的数据，来保证数据完整性。

### 二、版本保存机制

Git 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会**对当前的全部文件制作一个快照并保存这个快照的索引**。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

所以 Git 的工作方式可以称之为快照流。





## 集中式与分布式

![](images\集中式与分布式.png)

集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人电脑上都有一份完整的代码。

集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。

集中式版本控制需要联网才能工作，如果网速过慢，提交文件的速度会很慢，而分布式版本控制不需要联网就能工作。

分布式版本控制新建分支，合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。





## 中心服务器

用来交换每个用户的修改，没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。

Github 就是一个中心服务器。



## 本地库和远程库

团队内部协作

![](images\团队内部协作.png)

跨团队协作

![](images\跨团队协作.png)







## 工作流

新建一个仓库之后，当前目录就成为了工作区（写代码），工作区下有一个隐藏目录 .git，它属于 Git 的版本库。

Git 版本库有一个称为 **Stage 的暂存区**以及最后的 **History 版本库**，History 存储所有分支信息，使用一个 **HEAD 指针指向当前分支。**

![](images\工作区与版本库.png)



* git add files 把文件的修改添加到暂存区
* git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了
* git reset --files 使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files
* git checkout --files 使用暂存区的修改覆盖工作目录，用来撤销本地修改



![](images\工作流.png)



可以跳过暂存区，直接从分支中取出修改，或者直接提交修改到分支中。

* git commit -a  直接把所有文件的修改添加到暂存区然后执行提交
* git checkout HEAD --files 取出最后一次修改，可以用来进行回滚操作

![](images\工作流2.png)







## 分支实现

使用指针将每个提交连接成一条时间线，HEAD 指针指向当前分支指针

![](\images\使用指针将分支连接.png)



新建分支是**新建一个指针(Dev)**指向时间线的最后一个结点，并让 HEAD 指针指向新分支，表示新分支称为当前分支。

![](\images\新建分支.png)



每次提交只会让当前分支指针向前移动，而其它分支不会移动。

![](.\images\提交.png)



合并分支也只需改变指针即可。

![](images\合并.png)





## 冲突

当两个分支都对同一个文件的同一行进行了修改，在分支合并时就会产生冲突。

![](\images\冲突.png)

* 冲突的表现：

![](\images\冲突的表现.png)

### 解决冲突：

1. 编辑文件，删除特殊符号

2. 把不同分支中冲突部分修改成一样

3. git add [文件名]

4. git commit -m "日志信息"

   注意：此时 commit 一定不能带具体文件名





## Fast forward

“快进式合并”，会直接将 master 分支指向合并的分支，这种模式下进行分支合并**会丢失分支信息，也就不能在分支历史上看出分支信息**。

可以在合并时加上 --no-ff 参数来禁止 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit

```shell
$ git merge --no-ff -m "merge with no-ff" dev
```

![](\images\Fast forward.png)







## 储藏（Stashing）

在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都公用一个工作区的缘故。

可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的修改都会被存到栈中，也就是说当前工作区是干净的，没有未提交的修改，此时就可以安全切换到其他分支上了。

```shell
$ git stash
Saved working directory and index state \ "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file (To restore them type "git stash apply")
```

该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用此命令将 dev 分支的未提交修改储藏起来。





## SSH 传输设置

Git 仓库和 Github 中心仓库之间的传输是通过 SSH 加密的。

如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key：

```shell
$ ssh-keygen -t rsa -C "youremail@example.com"
```

然后把公钥 id_rsa.pub 的内容复制到 Github "Account settings" 的 SSH Keys 中。







## Gitflow

Gitflow 工作流通过为功能开发，发布准备和维护设备设立了独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。

![](\images\GitFlow工作流.png)

### 分支种类

* #### 主干分支 master

主要负责管理正在运行的**生产环境**代码，永远保持与正在运行的生产环境完全一致，不允许修改，只能合并

* #### bug 修理分支 hotfix

主要负责管理**生产环境下出现的紧急修复的代码**，从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。

* #### 准生产分支（预发布分支）release

较大版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段时间稳定后，可以视情况删除。

* #### 开发分支 develop

主要负责管理正在开发过程中的代码，一般情况下应该是最新的代码，测试过了，再合并到主分支

* #### 功能分支 feature

为了不影响较短周期的开发工作，一般会把中长期开发模块从开发分支中独立出来，开发完成后会合并到开发分支。



### 分支操作

#### 创建分支

```shell
git branch [分支名]
```

#### 查看分支

```shell
git branch -v
```

#### 切换分支

```shell
git checkout [分支名]
```

#### 合并分支

1. 切换到接受修改的分支（被合并，增加新内容的分支）

```shell
git checkout [被合并分分支名]
```

2. 执行 merge 命令

```shell
git merge [有新内容分支名]
```









## 基本操作

### 状态查看

```shell
git status
```

查看工作区，暂存区状态

### 添加

```shell
git add [file name]
```

将工作区的“新建/修改”添加到暂存区

### 提交

```shell
git commit -m "commit message" [file name]
```

将暂存区的内容提交到本地库

### 查看历史纪录

```shell
git log
```

### 删除文件并找回

```shell
git reset --hard [指针位置]
```

前提：删除前，文件存在时的状态提交到了本地库

### 比较文件差异

```shell
git diff [文件名]
```

将工作区中的文件和暂存区进行比较

### 创建远程库地址别名

```shell
git remote -v  // 查看当前所有远程地址别名
```

```shell
git remote add [别名][远程地址]
```

### 推送

```shell
git push [别名][分支名]
```

### 克隆

```shell
git clone [远程地址]
```

效果：

* 完整的把远程库下载到本地

* 创建 origin 远程地址别名
* 初始化本地库



### 拉取

```shell
git fetch [远程库地址别名][远程分支名]
git merge [远程库地址别名/远程分支名]
```

或者

```shell
git pull [远程库地址别名][远程分支名]
```

