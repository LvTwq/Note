[TOC]

# 一、IO框架设计：

## 1、为什么要有IO

程序要和外部进行数据交互。



## 2、文件系统

要学习IO流，就得针对某一个输入输出设备来学习。哪种输入输出设备最重要同时也最常见？当然是硬盘。硬盘在这里的含义也可以理解为文件系统。（Java程序是运行在某操作系统平台上的应用软件JVM上的，实际上Java程序可见的并不是硬盘，而是操作系统提供的文件系统，因此此处可直接理解为文件系统）。因此，我们学习IO流的时候，基本上是学习的Java如何操作文件系统。

要用Java操作文件系统，首先要表示文件，即 **File 类**。



## 3、抽象基类

然后，我们要操作文件，虽然我们大部分操作都是操作文件系统，但是要明白IO流的概念不仅仅局限在操作文件上，前面我已经提到了，我们的编程语言是要能操作所有的输入输出，因此，API提供了两个顶层抽象类，用来表示操作所有的输出输出：InputStream，OutputStream。

并且，这两个类表示字节的输入输出，而字节流是最基本的流，因为计算机底层传递的就是字节。



## 4、访问文件

当我们要操作文件的时候，就需要具体的对文件系统操作的IO实现类，FileInputStream和FileOutputStream，它们是文件输入输出字节流。这里之所以FileInputStream/OutputStream作为子类出现，按照面向对象思想理解就是，将来还有别的字节流来操作别的设备



## 5、缓冲流

但是原始的字节流对象不高效，每个读写请求都由底层操作系统处理，所以有了缓冲流

不带缓冲区的流对象，只能一个字节一个字节的读，每次都调用底层的操作系统API，非常低效，而带缓冲区的流对象，可以一次读一个缓冲区，缓冲区空了才去调用一次底层API，这就能大大提高效率。所以又有了BufferedInputStream和BufferedOutputSteam，他们的用法是把字节流对象传入后再使用，也相当于把它俩套在了字节流的外面，给字节流装了个“外挂”，让基本字节流如虎添翼。



## 6、转换流

InputStreamReader和OutputStreamWriter。这两个类的作用分别是把字节流转成字符流，把字符流转成字节流。但是这两个流需要套在现成的字节流上才能使用，当中用到的设计模式也就是常说的装饰模式。当字节流被转成字符流之后，可以不必操作字节流了，而是可以用人类的方式read和write各种“文字”。





## 7、字符输入输出流

最常见的是和文件系统打交道，那么针对如此常见的用途，读取文本文件能不能用一种方便的方式呢？当然，大牛们替你想到并提供了。FileReader和FileWriter这两个流对象可以直接把文件转成读取、写入流。让你省去了创建字节流，再套上转换流的步骤。看看这类名起的，实际上很形象，xxxReader和xxxWriter，明摆着告诉你“阅读和书写”都是“人可以做的”也就是他们表示的是字符流。同理上面的InputStreamReader和OutputStreamWriter，表示的是把字节流转成人可读的，把字节流转成人可写的。因此他们的顶层抽象类：Reader和Writer，表示的是所有人类可读可写的字符流统称。



## 8、字符缓冲流

再把Reader和Writer做成高效的，就需要BufferedReader和BufferedWriter，把它们套在Reader和Writer上，就能实现高效的字符流。





简单的记，字节流是基础，理论上可用于所有的输入输出场景，内容是文字的字节流可以通过转换流转成字符流，转换流是字节流和字符流之间相互转换的桥梁，把字节流转成字符流，离不开转换流，字符流是对于字符功能的增强可用来处理“文字”，操作文件系统应用范围最广，所以JDK提供了现成的FileXXX类，用来方便编程使用。

